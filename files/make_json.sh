#!/bin/bash

# Write JSON files for ENCODE ATAC pipeline input
# Assumes that reads are paired-end

set -e

show_help() {
cat << EOF
Usage: $0 -f [FASTQ DIR] -g [GENOME TSV] -j [JSON DIR] [OPTION]...
Generate a JSON configuration for the ENCODE ATAC pipeline

Mandatory options:
  -f <dir>                   fastq directory
  -g <file>                  genome file (likely a *.tsv)
  -j <dir>                   json directory

Options:
  -h                         display this help text
EOF
}

while getopts "f:g:hj:" opt; do
  case "$opt" in
    h)
      show_help
      exit 0
      ;;
    g)
      genome_ref=$OPTARG
      ;;
    f)
      fastq_dir=$OPTARG
      ;;
    j)
      json_dir=$OPTARG
      ;;
  esac
done

if [ -z $fastq_dir ] || [ -z $json_dir ] || [ -z $genome_ref ]; then
  echo "Missing mandatory command line argument!"
  show_help
  exit 1
fi

cat <<EOF
[info] Configuration:
[info]   fast_dir: $fastq_dir
[info]   json_dir: $json_dir
[info]   genome_ref: $genome_ref
EOF

mkdir -p ${json_dir}

# Emit all fastq files in the $fastq_dir based on a suffix
#   - param $1: the suffix to use, e.g., "_R1_001.fastq.gz"
emit_fastq() {
    suffix=$1

    fastq_r1=($(ls ${fastq_dir}/${i}_*L00*$suffix))
    for j in $(seq 1 ${#fastq_r1[@]}); do
        echo -n "        \"${fastq_rq[$j]}\"" >> ${json_file}
        if ! [ $j -eq ${#fastq_r1[@]} ]; then
            echo "," >> $json_file
        else
            echo "" >> $json_file
        fi
    done
}

indiv=$(ls -1 ${fastq_dir}/*_001.fastq.gz | perl -n -e '/([\-A-z0-9]+)_L[0-9]+/ && print "$1 "' | sort | uniq)

for i in $indiv; do

    # skip "Undetermined" FASTQs generated by bcl2fastq
    if [ `echo "$i" | grep "Undetermined"` ]; then
        continue
    fi

    # name JSON file from FASTQ sample name
    json_file=${json_dir}/${i}.json

    echo "{" > ${json_file}
    echo "    \"atac.title\" : \"${i}\"," >> ${json_file}
    echo "    \"atac.description\" : \"ATAC-seq on MoTrPAC\"," >> ${json_file}
    echo "    \"atac.pipeline_type\" : \"atac\"," >> ${json_file}
    echo "    \"atac.genome_tsv\" : \"${genome_ref}\"," >> ${json_file}
    echo "    \"atac.keep_irregular_chr_in_bfilt_peak\" : true," >> ${json_file} # required when using Ensembl reference genome, which has non-standard chromosome names
    echo >> ${json_file}

    echo "    \"atac.paired_end\" : true," >> ${json_file}
    echo "    \"atac.multimapping\" : 0," >> ${json_file}
    echo >> ${json_file}

    echo "    \"atac.auto_detect_adapter\" : true," >> ${json_file}
    echo >> ${json_file}

    # allocate CPUs
    echo "    \"atac.trim_adapter_cpu\" : 4," >> ${json_file}
    echo "    \"atac.bowtie2_cpu\" : 4," >> ${json_file}
    echo "    \"atac.filter_cpu\" : 4," >> ${json_file}
    echo "    \"atac.bam2ta_cpu\" : 4," >> ${json_file}
    echo "    \"atac.xcor_cpu\" : 4," >> ${json_file}
    echo >> ${json_file}

    # allocate memory
    echo "    \"atac.bowtie2_mem_mb\" : 16000," >> ${json_file}
    echo "    \"atac.filter_mem_mb\" : 16000," >> ${json_file}
    echo "    \"atac.macs2_mem_mb\" : 16000," >> ${json_file}
    echo >> ${json_file}

    # optional. we can set this to false if we're only interested in the less stringent "overlap" peak sets
    echo "    \"atac.enable_idr\" : true," >> ${json_file}
    echo >> ${json_file}

    echo "    \"atac.fastqs_rep1_R1\" : [" >> ${json_file}
    emit_fastq _R1_001.fastq.gz
    echo "    ]," >> ${json_file}

    echo "    \"atac.fastqs_rep1_R2\" : [" >> ${json_file}
    emit_fastq _R2_001.fastq.gz
    echo "    ]" >> ${json_file}

    echo "}" >> ${json_file}

done
